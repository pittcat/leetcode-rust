// ============================================================================
// LeetCode 7: 整数反转 (Reverse Integer)
// ============================================================================
// 难度: 中等
// 链接: https://leetcode.cn/problems/reverse-integer/
//
// 题目描述:
// 给你一个 32 位的有符号整数 x，返回将 x 中的数字部分反转后的结果。
// 如果反转后整数超过 32 位的有符号整数的范围 [−2³¹, 2³¹ − 1]，就返回 0。
//
// 示例:
// 输入: x = 123
// 输出: 321
//
// 输入: x = -123
// 输出: -321
//
// 输入: x = 120
// 输出: 21
//
// 约束条件:
// - -2³¹ <= x <= 2³¹ - 1
// - 假设环境不允许存储 64 位整数（有符号或无符号）
// ============================================================================

pub struct Solution;

impl Solution {
    pub fn reverse(x: i32) -> i32 {
        todo!();
        // ====================================================================
        // 【核心算法】数学方法 - 逐位反转
        // ====================================================================
        // 思路:
        // 1. 用 x % 10 取出最后一位数字
        // 2. 用 x / 10 去掉最后一位
        // 3. 将取出的数字加到结果的末尾: result = result * 10 + digit
        // 4. 重复直到 x 为 0
        //
        // 关键难点: **溢出检测** (Rust vs Python 的重要区别!)
        // ====================================================================

        // ====================================================================
        // 第 1 步: 初始化变量
        // ====================================================================
        // TODO: 声明一个可变的结果变量
        //
        // let mut result: i32 = 0;
        //
        // 为什么用 i32?
        // - 题目要求返回 i32
        // - 我们需要在计算过程中检测溢出
        //
        // 为什么用 mut?
        // - result 会在循环中不断更新
        // - Rust 默认变量不可变，需要显式声明 mut

        // 你的代码写在这里 ↓
        let mut result


        // ====================================================================
        // 第 2 步: 创建可变的 x
        // ====================================================================
        // TODO: 因为我们需要修改 x，需要创建一个可变副本
        //
        // let mut x = x;
        //
        // 为什么这样写?
        // - 函数参数 x 默认是不可变的
        // - Rust 允许用相同名字"遮蔽"(shadow)原变量
        // - 这是 Rust 的惯用写法，避免起名如 x_mut

        // 你的代码写在这里 ↓

        // ====================================================================
        // 第 3 步: 主循环 - 逐位提取并反转
        // ====================================================================
        // TODO: 当 x != 0 时继续循环
        //
        // while x != 0 {
        //     // 3.1 提取最后一位数字
        //     // 3.2 溢出检测（重点！）
        //     // 3.3 更新 result
        //     // 3.4 去掉 x 的最后一位
        // }

        // 你的代码写在这里 ↓
        // TODO: 实现 while 循环
        // while x != 0 {
        //     // ================================================================
        //     // 第 3.1 步: 提取最后一位数字
        //     // ================================================================
        //     // TODO: 使用模运算提取数字
        //     //
        //     // let digit = x % 10;
        //     //
        //     // 关键知识点: Rust 中负数的模运算
        //     // - -123 % 10 = -3 (保留符号)
        //     // - -123 / 10 = -12 (向零取整)
        //     //
        //     // 这与 Python 不同!
        //     // - Python: -123 % 10 = 7, -123 // 10 = -13
        //
        //     // 你的代码写在这里 ↓
        //
        //
        //     // ================================================================
        //     // 第 3.2 步: 【重点】溢出检测
        //     // ================================================================
        //     // TODO: 在执行 result * 10 + digit 之前检测溢出
        //     //
        //     // 为什么要在之前检测?
        //     // - 如果先计算 result * 10，已经溢出了就来不及了
        //     // - Rust 在 release 模式下溢出会"回绕"，不会报错
        //     //
        //     // 检测方法:
        //     // result * 10 + digit 会溢出 ⟺
        //     //   result > i32::MAX / 10  或
        //     //   result == i32::MAX / 10 且 digit > 7  或
        //     //   result < i32::MIN / 10  或
        //     //   result == i32::MIN / 10 且 digit < -8
        //     //
        //     // 为什么是 7 和 -8?
        //     // - i32::MAX = 2147483647，最后一位是 7
        //     // - i32::MIN = -2147483648，最后一位是 -8
        //     //
        //     // 条件写成:
        //     // if result > i32::MAX / 10 || (result == i32::MAX / 10 && digit > 7) {
        //     //     return 0;
        //     // }
        //     // if result < i32::MIN / 10 || (result == i32::MIN / 10 && digit < -8) {
        //     //     return 0;
        //     // }
        //
        //     // 你的代码写在这里 ↓
        //
        //
        //     // ================================================================
        //     // 第 3.3 步: 更新 result
        //     // ================================================================
        //     // TODO: 将新数字加到 result 的末尾
        //     //
        //     // result = result * 10 + digit;
        //     //
        //     // 为什么这样更新?
        //     // - result * 10: 将现有数字左移一位（十进制）
        //     // - + digit: 在个位上加上新数字
        //     //
        //     // 例如: result = 12, digit = 3
        //     // result = 12 * 10 + 3 = 123
        //
        //     // 你的代码写在这里 ↓
        //
        //
        //     // ================================================================
        //     // 第 3.4 步: 去掉 x 的最后一位
        //     // ================================================================
        //     // TODO: 使用整数除法
        //     //
        //     // x /= 10;
        //     //
        //     // 效果:
        //     // - 123 / 10 = 12
        //     // - -123 / 10 = -12 (向零取整)
        //
        //     // 你的代码写在这里 ↓
        //
        // }

        // ====================================================================
        // 第 4 步: 返回结果
        // ====================================================================
        // TODO: 循环结束后返回 result
        //
        // 如果没有溢出，result 就是反转后的数字

        // 你的代码写在这里 ↓
    }
}

// ============================================================================
// 【进阶】另一种实现方式: 使用 checked_* 方法
// ============================================================================
// Rust 提供了一系列 checked_* 方法来安全地处理溢出:
//
// impl Solution {
//     pub fn reverse_v2(x: i32) -> i32 {
//         let mut result = 0i32;
//         let mut x = x;
//
//         while x != 0 {
//             let digit = x % 10;
//             x /= 10;
//
//             // checked_mul 返回 Option<i32>
//             // 如果溢出则返回 None
//             result = match result.checked_mul(10) {
//                 Some(val) => match val.checked_add(digit) {
//                     Some(new_result) => new_result,
//                     None => return 0,
//                 },
//                 None => return 0,
//             };
//         }
//
//         result
//     }
// }
//
// 优点: 更符合 Rust 的惯用法，利用类型系统保证安全
// 缺点: 相比手动检测稍微啰嗦一点
//
// 你可以在完成基础版本后尝试实现这个版本!
// ============================================================================

// ============================================================================
// 测试用例
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_example_1() {
        assert_eq!(Solution::reverse(123), 321);
    }

    #[test]
    fn test_example_2() {
        assert_eq!(Solution::reverse(-123), -321);
    }

    #[test]
    fn test_example_3() {
        // 末尾的 0 应该被去掉
        assert_eq!(Solution::reverse(120), 21);
    }

    #[test]
    fn test_zero() {
        assert_eq!(Solution::reverse(0), 0);
    }

    #[test]
    fn test_single_digit() {
        assert_eq!(Solution::reverse(5), 5);
        assert_eq!(Solution::reverse(-5), -5);
    }

    #[test]
    fn test_overflow_positive() {
        // 1534236469 反转后是 9646324351，超过 i32::MAX
        assert_eq!(Solution::reverse(1534236469), 0);
    }

    #[test]
    fn test_overflow_negative() {
        // -2147483648 (i32::MIN) 反转会溢出
        assert_eq!(Solution::reverse(-2147483648), 0);
    }

    #[test]
    fn test_near_max() {
        // 1463847412 反转后是 2147483641，在范围内
        assert_eq!(Solution::reverse(1463847412), 2147483641);
    }

    #[test]
    fn test_trailing_zeros() {
        assert_eq!(Solution::reverse(1200), 21);
        assert_eq!(Solution::reverse(-1000), -1);
    }
}
