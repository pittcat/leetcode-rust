// ============================================================================
// LeetCode 9: 回文数 (Palindrome Number)
// ============================================================================
// 难度: 简单
// 链接: https://leetcode.cn/problems/palindrome-number/
//
// 题目描述:
// 给定一个整数 x，如果 x 是回文整数，返回 true；否则，返回 false。
// 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
//
// 示例:
// 输入: x = 121
// 输出: true
//
// 输入: x = -121
// 输出: false (从左向右是 -121，从右向左是 121-)
//
// 输入: x = 10
// 输出: false (从右向左读为 01)
//
// 约束条件:
// - -2³¹ <= x <= 2³¹ - 1
//
// 进阶:
// - 你能不将整数转换为字符串来解决这个问题吗？
// ============================================================================

pub struct Solution;

impl Solution {
    pub fn is_palindrome(x: i32) -> bool {
        // ====================================================================
        // 【核心思路】反转一半数字进行比较
        // ====================================================================
        // 方法 1: 转换为字符串（简单但不够优雅）
        // 方法 2: 完全反转数字（可能溢出）
        // 方法 3: 只反转一半（最优解！） ← 我们使用这个
        //
        // 为什么反转一半？
        // - 避免溢出问题（不需要存储完整的反转数）
        // - 效率更高（只需要处理一半的数字）
        //
        // 核心思想:
        // 1221 → 反转右半部分得到 12 和 12 → 相等 ✓
        // 12321 → 反转右半部分得到 12 和 123 → 去掉中间数字后相等 ✓
        // ====================================================================

        // ====================================================================
        // 第 1 步: 特殊情况处理
        // ====================================================================
        // TODO: 快速判断以下情况
        //
        // 情况 1: 负数一定不是回文数
        // - 因为负号在左边，反转后在右边
        // - if x < 0 { return false; }
        //
        // 情况 2: 末尾为 0 的数字（除了 0 本身）不是回文数
        // - 例如: 10 反转后是 01，不等于 10
        // - 但 0 本身是回文数
        // - if x != 0 && x % 10 == 0 { return false; }
        //
        // 为什么这样写？
        // - x != 0: 排除 0 本身（0 是回文数）
        // - x % 10 == 0: 末尾是 0
        // - 这两个条件同时满足才返回 false

        // 你的代码写在这里 ↓
        if x < 0 || (x != 0 && x % 10 == 0) {
            return false;
        }

        // ====================================================================
        // 第 2 步: 初始化反转数字
        // ====================================================================
        // TODO: 声明一个变量存储反转后的一半数字
        //
        // let mut reversed_half = 0;
        //
        // 为什么只存储一半？
        // - 我们只反转右半部分
        // - 例如: 1221 → 只反转 21 得到 12
        //         12321 → 只反转 321 得到 123

        // 你的代码写在这里 ↓
        let mut reversed_half = 0;

        // ====================================================================
        // 第 3 步: 创建可变的 x
        // ====================================================================
        // TODO: 因为我们需要修改 x，创建一个可变副本
        //
        let mut x = x;
        //
        // Rust 知识点: shadowing（遮蔽）
        // - 用相同名字声明新变量，"遮蔽"原变量
        // - 这是 Rust 的惯用写法

        // 你的代码写在这里 ↓

        // ====================================================================
        // 第 4 步: 反转右半部分数字
        // ====================================================================
        // TODO: 当左半部分 > 右半部分时，继续反转
        //
        // 循环条件: while x > reversed_half
        //
        // 为什么是 x > reversed_half？
        // - 当右半部分的长度 >= 左半部分时，说明已经处理了一半
        //
        // 例如: 1221
        // 初始: x = 1221, reversed_half = 0
        // 第 1 次: x = 122, reversed_half = 1
        // 第 2 次: x = 12, reversed_half = 12 → x <= reversed_half，退出
        //
        // 例如: 12321
        // 初始: x = 12321, reversed_half = 0
        // 第 1 次: x = 1232, reversed_half = 1
        // 第 2 次: x = 123, reversed_half = 12
        // 第 3 次: x = 12, reversed_half = 123 → x <= reversed_half，退出
        while x > reversed_half {
            reversed_half = reversed_half * 10 + x % 10;
            x = x / 10;
        }

        x == reversed_half || x == reversed_half / 10

        // 你的代码写在这里 ↓
        // TODO: 实现 while 循环
        // while x > reversed_half {
        //     // ================================================================
        //     // 第 4.1 步: 将 x 的最后一位加到 reversed_half
        //     // ================================================================
        //     // TODO: 更新 reversed_half
        //     //
        //     // reversed_half = reversed_half * 10 + x % 10;
        //     //
        //     // 这和整数反转的逻辑一样:
        //     // - x % 10: 取出最后一位
        //     // - reversed_half * 10: 现有数字左移一位
        //     // - 相加: 将新数字加到末尾
        //
        //     // 你的代码写在这里 ↓
        //
        //
        //     // ================================================================
        //     // 第 4.2 步: 去掉 x 的最后一位
        //     // ================================================================
        //     // TODO: 使用整数除法
        //     //
        //     // x /= 10;
        //     //
        //     // 效果: 1221 → 122 → 12
        //
        //     // 你的代码写在这里 ↓
        //
        // }

        // ====================================================================
        // 第 5 步: 判断是否为回文
        // ====================================================================
        // TODO: 比较左半部分和右半部分
        //
        // 需要考虑两种情况:
        //
        // 情况 1: 偶数位数字 (如 1221)
        // - 左半部分: x = 12
        // - 右半部分: reversed_half = 12
        // - 判断: x == reversed_half
        //
        // 情况 2: 奇数位数字 (如 12321)
        // - 左半部分: x = 12
        // - 右半部分: reversed_half = 123
        // - 中间数字不影响回文判断，需要去掉
        // - 判断: x == reversed_half / 10
        //
        // 最终条件: x == reversed_half || x == reversed_half / 10
        //
        // 为什么这样写？
        // - 用 || 同时处理奇数和偶数长度
        // - reversed_half / 10: 去掉中间数字

        // 你的代码写在这里 ↓
    }
}

// ============================================================================
// 【进阶】其他实现方法
// ============================================================================
//
// 方法 1: 转换为字符串（不推荐，但最直观）
// ------------------------------------------------
// impl Solution {
//     pub fn is_palindrome_v2(x: i32) -> bool {
//         if x < 0 {
//             return false;
//         }
//
//         let s = x.to_string();
//         let reversed: String = s.chars().rev().collect();
//         s == reversed
//     }
// }
//
// 优点: 代码简洁，易懂
// 缺点:
//   1. 需要额外空间存储字符串
//   2. 字符串操作比数学运算慢
//   3. 不符合"进阶"要求
//
//
// 方法 2: 完全反转法（类似 LeetCode 7）
// ------------------------------------------------
// impl Solution {
//     pub fn is_palindrome_v3(x: i32) -> bool {
//         if x < 0 {
//             return false;
//         }
//
//         let original = x;
//         let mut reversed = 0;
//         let mut x = x;
//
//         while x != 0 {
//             reversed = reversed * 10 + x % 10;
//             x /= 10;
//         }
//
//         original == reversed
//     }
// }
//
// 优点: 逻辑清晰
// 缺点: 对于大数可能需要考虑溢出（虽然回文数不会溢出）
//
//
// 为什么我们选择"反转一半"的方法？
// - 不需要额外存储原始值
// - 不需要担心溢出问题
// - 性能更好（只处理一半的数字）
// - 更符合 Rust 的"零成本抽象"理念
// ============================================================================

// ============================================================================
// 测试用例
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_example_1() {
        // 121 是回文数
        assert_eq!(Solution::is_palindrome(121), true);
    }

    #[test]
    fn test_example_2() {
        // 负数不是回文数
        assert_eq!(Solution::is_palindrome(-121), false);
    }

    #[test]
    fn test_example_3() {
        // 末尾为 0 的数不是回文数（除了 0）
        assert_eq!(Solution::is_palindrome(10), false);
    }

    #[test]
    fn test_zero() {
        // 0 是回文数
        assert_eq!(Solution::is_palindrome(0), true);
    }

    #[test]
    fn test_single_digit() {
        // 单个数字都是回文数
        assert_eq!(Solution::is_palindrome(7), true);
        assert_eq!(Solution::is_palindrome(9), true);
    }

    #[test]
    fn test_even_length_palindrome() {
        // 偶数长度的回文数
        assert_eq!(Solution::is_palindrome(1221), true);
        assert_eq!(Solution::is_palindrome(123321), true);
    }

    #[test]
    fn test_odd_length_palindrome() {
        // 奇数长度的回文数
        assert_eq!(Solution::is_palindrome(12321), true);
        assert_eq!(Solution::is_palindrome(1), true);
    }

    #[test]
    fn test_not_palindrome() {
        // 不是回文数的情况
        assert_eq!(Solution::is_palindrome(123), false);
        assert_eq!(Solution::is_palindrome(1234), false);
    }

    #[test]
    fn test_trailing_zeros() {
        // 末尾有 0 的数字
        assert_eq!(Solution::is_palindrome(100), false);
        assert_eq!(Solution::is_palindrome(1000), false);
    }

    #[test]
    fn test_large_palindrome() {
        // 较大的回文数
        assert_eq!(Solution::is_palindrome(123454321), true);
    }

    #[test]
    fn test_near_palindrome() {
        // 差一点点的数字
        assert_eq!(Solution::is_palindrome(1231), false);
        assert_eq!(Solution::is_palindrome(12312), false);
    }
}
